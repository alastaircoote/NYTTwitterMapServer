// Generated by CoffeeScript 1.3.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  define(["jslib/leaflet", "./coordinate", "jslib/jsbezier", "jslib/jq.color"], function(L, Coordinate, jsBezier, jC) {
    var LineLayer;
    window.requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
      return window.setTimeout(callback, 1000 / 60);
    };
    return LineLayer = (function() {

      LineLayer.prototype.lineWidth = 2;

      function LineLayer(fromLatlng, toLatLng, hue) {
        this.fromLatlng = fromLatlng;
        this.toLatLng = toLatLng;
        this.hue = hue;
        this.doDraw = __bind(this.doDraw, this);

        this.calculatePoints = __bind(this.calculatePoints, this);

        this.drawLine = __bind(this.drawLine, this);

        this.calculateDimensions = __bind(this.calculateDimensions, this);

        this.onReset = __bind(this.onReset, this);

        this.onRemove = __bind(this.onRemove, this);

        this.onAdd = __bind(this.onAdd, this);

      }

      LineLayer.prototype.onAdd = function(map) {
        this.map = map;
        this._el = $('<canvas/>');
        this.canvas = this._el[0].getContext("2d");
        map.getPanes().overlayPane.appendChild(this._el[0]);
        map.on('viewreset', this.onReset, this);
        return this.onReset();
      };

      LineLayer.prototype.onRemove = function() {
        this._el.remove();
        return this.map.off('viewreset', this.onReset, this);
      };

      LineLayer.prototype.onReset = function() {
        this.startPos = this.map.latLngToLayerPoint(this.fromLatlng);
        this.endPos = this.map.latLngToLayerPoint(this.toLatLng);
        this.calculateDimensions();
        return this.drawLine();
      };

      LineLayer.prototype.calculateDimensions = function() {
        var cssProps;
        cssProps = {
          position: "absolute"
        };
        this.startPosPx = {};
        this.endPosPx = {};
        this.controlPoints = [0, 1, 2, 3].map(function() {
          return new Coordinate;
        });
        this.size = {
          height: Math.abs(this.startPos.y - this.endPos.y),
          width: Math.abs(this.startPos.x - this.endPos.x)
        };
        if (this.startPos.y > this.endPos.y) {
          cssProps.top = this.endPos.y;
          this.controlPoints[0].y = this.size.height;
          this.controlPoints[3].y = 0;
        } else {
          cssProps.top = this.startPos.y;
          this.controlPoints[0].y = 0;
          this.controlPoints[3].y = this.size.height;
        }
        if (this.startPos.x > this.endPos.x) {
          cssProps.left = this.endPos.x;
          this.controlPoints[0].x = this.size.width;
          this.controlPoints[1].x = this.size.width - (this.size.width / 4);
          this.controlPoints[2].x = this.size.width / 4;
          this.controlPoints[3].x = 0;
        } else {
          cssProps.left = this.startPos.x;
          this.controlPoints[0].x = 0;
          this.controlPoints[1].x = this.size.width / 4;
          this.controlPoints[2].x = this.size.width - (this.size.width / 4);
          this.controlPoints[3].x = this.size.width;
        }
        this.controlPoints[1].y = this.controlPoints[0].y - (this.size.width / 4);
        this.controlPoints[2].y = this.controlPoints[0].y - (this.size.width / 4);
        this.controlPoints.reverse();
        this.calculatePoints();
        this.size.height += this.extraHeight + this.lineWidth;
        this.size.width += this.lineWidth;
        cssProps.top -= this.extraHeight;
        this._el.css(cssProps);
        return this._el.attr(this.size);
      };

      LineLayer.prototype.drawLine = function() {
        var drawFrame, duration, endTime, first, grd, mid, percentDrawn, startTime,
          _this = this;
        this.canvas.strokeStyle = "white";
        grd = this.canvas.createLinearGradient(0, 0, this.size.width, this.size.height);
        console.log(this.hue);
        first = $.Color({
          hue: this.hue,
          saturation: 0.66,
          lightness: 0.43,
          alpha: 1
        }).toHexString();
        mid = $.Color({
          hue: this.hue,
          saturation: 0.56,
          lightness: 0.69,
          alpha: 1
        }).toHexString();
        grd.addColorStop(0, first);
        grd.addColorStop(0.3, first);
        grd.addColorStop(0.5, mid);
        grd.addColorStop(0.7, first);
        grd.addColorStop(1, first);
        this.canvas.fillStyle = grd;
        this.canvas.lineCap = "round";
        this.canvas.lineWidth = this.lineWidth;
        percentDrawn = 0;
        startTime = Date.now();
        duration = 2000;
        endTime = startTime + duration;
        drawFrame = function() {
          percentDrawn = ((duration - (endTime - Date.now())) / duration) * 100;
          _this.canvas.clearRect(0, 0, _this.size.width, _this.size.height);
          _this.doDraw(Math.floor(percentDrawn));
          if (percentDrawn <= 200) {
            return window.requestAnimFrame(drawFrame);
          } else {
            return _this.map.removeLayer(_this);
          }
        };
        return window.requestAnimFrame(drawFrame);
        /*
                    drawTimeout = () =>
                        setTimeout () =>
                            @canvas.clearRect(0,0,@size.width,@size.height)
                            @doDraw(percentDrawn)
                            percentDrawn++
                            if percentDrawn <= 200 then drawTimeout()
                        ,5
                    drawTimeout()
        */

      };

      LineLayer.prototype.calculatePoints = function() {
        var lowestY, pointMap, _i, _j, _results, _results1,
          _this = this;
        lowestY = 0;
        this.secondLinePoints = this.controlPoints.map(function(p, i) {
          if (i === 1 || i === 2) {
            return new Coordinate(p.x, p.y - 15);
          } else {
            return new Coordinate(p.x, p.y);
          }
        });
        pointMap = function(points) {
          return function(p) {
            var point;
            point = jsBezier.pointOnCurve(points, p / 100);
            if (point.y < lowestY) {
              lowestY = point.y;
            }
            return point;
          };
        };
        this.points = (function() {
          _results = [];
          for (_i = 0; _i <= 100; _i++){ _results.push(_i); }
          return _results;
        }).apply(this).map(pointMap(this.controlPoints));
        this.secondLinePoints = (function() {
          _results1 = [];
          for (_j = 0; _j <= 100; _j++){ _results1.push(_j); }
          return _results1;
        }).apply(this).map(pointMap(this.secondLinePoints));
        return this.extraHeight = 0 - lowestY;
      };

      LineLayer.prototype.doDraw = function(percent) {
        var nextPoint, startFrom, startPoint, x, _i, _j;
        startFrom = 0;
        if (percent > 100) {
          startFrom = percent - 100;
          percent = 100;
          this.canvas.strokeStyle = "rgba(0, 0, 0, " + Math.round(10 - startFrom / 10, 2) / 10 + ")";
        }
        startPoint = this.points[startFrom];
        this.canvas.moveTo(startPoint.x, startPoint.y);
        this.canvas.beginPath();
        for (x = _i = startFrom; startFrom <= percent ? _i < percent : _i > percent; x = startFrom <= percent ? ++_i : --_i) {
          nextPoint = this.points[x];
          try {
            this.canvas.lineTo(nextPoint.x + (this.lineWidth / 2), nextPoint.y + this.extraHeight + (this.lineWidth / 2));
          } catch (error) {
            console.log(this.points.length, x);
          }
        }
        for (x = _j = percent; percent <= startFrom ? _j < startFrom : _j > startFrom; x = percent <= startFrom ? ++_j : --_j) {
          nextPoint = this.secondLinePoints[x];
          this.canvas.lineTo(nextPoint.x + (this.lineWidth / 2), nextPoint.y + this.extraHeight + (this.lineWidth / 2));
        }
        return this.canvas.fill();
      };

      return LineLayer;

    })();
  });

}).call(this);
