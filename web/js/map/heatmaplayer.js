// Generated by CoffeeScript 1.3.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(["jslib/leaflet", "./coordinate", "jslib/heatmap", "./heatmaptile"], function(L, Coordinate, HeatMap, HeatMapTile) {
    var HeatMapLayer;
    window.requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
      return window.setTimeout(callback, 1000 / 60);
    };
    return HeatMapLayer = (function(_super) {

      __extends(HeatMapLayer, _super);

      HeatMapLayer.prototype.paused = false;

      function HeatMapLayer(options) {
        this.setDataRaw = __bind(this.setDataRaw, this);

        this.animate = __bind(this.animate, this);

        this.resume = __bind(this.resume, this);

        this.pause = __bind(this.pause, this);

        this.setData = __bind(this.setData, this);

        this.adjustTilesAfterZoom = __bind(this.adjustTilesAfterZoom, this);

        this.setRadius = __bind(this.setRadius, this);

        this.resetTiles = __bind(this.resetTiles, this);
        this.tiles = [];
        this.stopAnimation = false;
      }

      HeatMapLayer.prototype.drawTile = function(canvas, point) {
        this.tiles.push(new HeatMapTile(this, canvas, point, 10));
      };

      HeatMapLayer.prototype.resetTiles = function(z1, z2) {
        return this.tiles = [];
      };

      HeatMapLayer.prototype.onAdd = function(map) {
        var _this = this;
        map.on("zoomstart", function() {
          var tile, _i, _len, _ref;
          _this.pause();
          _ref = _this.tiles;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            tile = _ref[_i];
            tile.hm.clear();
          }
          return _this.resetTiles();
        });
        map.on("zoomend", this.resume);
        map.on("moveend", this.resume);
        map.on("movestart", this.pause);
        this.setRadius(map);
        map.on("click", function() {
          if (_this.paused) {
            return _this.resume();
          } else {
            return _this.pause();
          }
        });
        return HeatMapLayer.__super__.onAdd.call(this, map);
      };

      HeatMapLayer.prototype.setRadius = function(map) {
        return this.radius = 10;
      };

      HeatMapLayer.prototype.adjustTilesAfterZoom = function() {
        this.setRadius(this._map);
        this.projectAndRoundPoints();
        this.setData(this.currentData);
        this.assignPointsToTiles();
        return this.redrawAllTiles();
      };

      HeatMapLayer.prototype.redrawAllTiles = function() {
        var tile, _i, _len, _ref, _results;
        _ref = this.tiles;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          tile = _ref[_i];
          _results.push(tile.draw());
        }
        return _results;
      };

      HeatMapLayer.prototype.setData = function(data) {
        return this.data = data;
      };

      HeatMapLayer.prototype.pause = function() {
        console.log("pause");
        this.paused = true;
        if (this.data && this.lowIndex) {
          return this.pausePoint = this.data[this.lowIndex].date;
        }
      };

      HeatMapLayer.prototype.resume = function() {
        console.log("resume");
        if (!this.hasEverStarted || !this.paused) {
          return console.log("NO");
        }
        this.paused = false;
        return this.animate();
      };

      HeatMapLayer.prototype.animate = function() {
        var articleCountMaps, articleCounts, doDraw, interval, multiplier, startDate, startMoment,
          _this = this;
        this.hasEverStarted = true;
        interval = 10 * 60 * 1000;
        this.lowIndex = 0;
        startDate = this.pausePoint || 1352200631000;
        startMoment = new Date().valueOf();
        multiplier = 1000;
        articleCounts = [];
        articleCountMaps = {};
        doDraw = function() {
          var d, dateMoment, i, lower, toDraw, upper;
          dateMoment = startDate + ((new Date().valueOf() - startMoment) * multiplier);
          if (_this.paused) {
            return;
          }
          lower = dateMoment - interval;
          upper = dateMoment + interval;
          while (_this.data[_this.lowIndex].date < lower) {
            _this.lowIndex++;
          }
          toDraw = [];
          i = _this.lowIndex;
          if (i >= _this.data.length) {
            return;
          }
          while (_this.data[i].date <= upper) {
            d = _this.data[i];
            if (!articleCountMaps[d.article]) {
              articleCountMaps[d.article] = articleCounts.length;
              articleCounts.push([d.article, 1]);
            } else {
              articleCounts[articleCountMaps[d.article]][1]++;
            }
            toDraw.push({
              lat: d.lat,
              lng: d.lng,
              count: 50 * (1 - Math.abs(d.date - dateMoment) / (upper - lower))
            });
            i++;
          }
          articleCounts.sort(function(a, b) {
            return b[1] - a[1];
          });
          _this.fire("articlelist", {
            articleCounts: articleCounts
          });
          _this.fire("datechange", {
            dateMoment: dateMoment
          });
          _this.setDataRaw(toDraw);
          return window.requestAnimFrame(function() {
            return doDraw();
          });
        };
        return window.requestAnimFrame(function() {
          return doDraw();
        });
      };

      HeatMapLayer.prototype.setDataRaw = function(data) {
        var point, projected, tile, _i, _j, _k, _len, _len1, _len2, _ref, _ref1,
          _this = this;
        _ref = this.tiles;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          tile = _ref[_i];
          tile.points = [];
        }
        projected = data.map(function(data) {
          var proj;
          proj = _this._map.project([data.lat, data.lng]);
          return {
            x: proj.x,
            y: proj.y,
            count: data.count
          };
        });
        for (_j = 0, _len1 = projected.length; _j < _len1; _j++) {
          point = projected[_j];
          _ref1 = this.tiles;
          for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
            tile = _ref1[_k];
            if (tile.pixelBounds.contains([point.x, point.y])) {
              tile.points.push(point);
            }
          }
        }
        return this.redrawAllTiles();
      };

      return HeatMapLayer;

    })(L.TileLayer.Canvas);
  });

}).call(this);
